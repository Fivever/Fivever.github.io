---
layout: post
title: 贪婪算法
date: 2019-04-18
categories: 算法训练
tag: 读书笔记
---

* content
{:toc}

## 货箱装载

### 贪婪法求解

把货箱分布装载到货船上，一步装载一个货箱。每一步决定装载哪一个货箱。做决定所依据的贪婪准则是：从剩下的货箱中，选择重量最小的货箱。这样可以保证所选的货箱总重量最小，从而使货船用最大的容量来装载更多的货物。

假设n=8，<img src="https://latex.codecogs.com/png.latex?[w_1,...,w_8]=[100,200,50,90,150,20,20,80]">，c=400。利用上述的贪婪算法，按装载货箱为7,3,6,8,4,1,5,2。货箱7,3,6,8,4,1的总重量为390，把它们装载之后欧，货船可用的装载容量为10，已经装不下任何一个货箱。得到的解为<img src="https://latex.codecogs.com/png.latex?[x_1,...,x_8]=[1,0,1,1,0,1,1,1]">，共6个货箱。

### 贪婪算法的正确性

令<img src="https://latex.codecogs.com/png.latex?x=[x_1,...,x_n]">是用贪婪算法得到的解，<img src="https://latex.codecogs.com/png.latex?y=[y_1,...,y_n]">是任意一个可行解。要证明<img src="https://latex.codecogs.com/png.latex?\sum_{i=1}^nx_i\geqslant \sum_{i=1}^ny_i">，不失一般性，假设货箱都已排序：<img src="https://latex.codecogs.com/png.latex?w_i\leqslant w_{i+1},(1\leqslant i< n)">。

根据上述贪婪算法可知，存在一个<img src="https://latex.codecogs.com/png.latex?k(0\leqslant k\leqslant n)">，使得<img src="https://latex.codecogs.com/png.latex?i\leqslant k">时<img src="https://latex.codecogs.com/png.latex?x_i=1">，且i>k时<img src="https://latex.codecogs.com/png.latex?x_i=0">。假设<img src="https://latex.codecogs.com/png.latex?x_i \neq y_i">的i的数量p应用归纳法。

- 归纳基础：当p=0时，x和y相等。因此<img src="https://latex.codecogs.com/png.latex?\sum_{i=1}^nx_i\geqslant \sum_{i=1}^ny_i">。

- 归纳假设：令m是任意一个自然数，假设<img src="https://latex.codecogs.com/png.latex?p\leqslant m">时有<img src="https://latex.codecogs.com/png.latex?\sum_{i=1}^nx_i\geqslant \sum_{i=1}^ny_i">成立。

- 归纳步骤：要证明当p=m+1时，<img src="https://latex.codecogs.com/png.latex?\sum_{i=1}^nx_i\geqslant \sum_{i=1}^ny_i">。寻找最小整数j，<img src="https://latex.codecogs.com/png.latex?1\leqslant j\leqslant n">，使得<img src="https://latex.codecogs.com/png.latex?x_i\neq y_i">。因为<img src="https://latex.codecogs.com/png.latex?p\neq 0">，所以存在这样一个j。又因为x已经是贪婪算法的解，所以y要是可行解的话，必须满足<img src="https://latex.codecogs.com/png.latex?j\leqslant k">，否则y不是可行解。所以<img src="https://latex.codecogs.com/png.latex?x_j=1">，<img src="https://latex.codecogs.com/png.latex?y_j=0">，之后令<img src="https://latex.codecogs.com/png.latex?y_j=0">。因为y是一个可行解，那么令z表示y。这时在范围[k+1,n]内必然存在一个l，使得<img src="https://latex.codecogs.com/png.latex?y_l=1">。令<img src="https://latex.codecogs.com/png.latex?y_l=0">，用z表示y。因为<img src="https://latex.codecogs.com/png.latex?w_j\leqslant w_l">，所以z是一个可行解。因为在任何情况下<img src="https://latex.codecogs.com/png.latex?\sum_{i=1}^nz_i\geqslant \sum_{i=1}^ny_i">，而且最多在p=m+1的位置上z与x不同。

由归纳假设得到：<img src="https://latex.codecogs.com/png.latex?\sum_{i=1}^nx_i\geqslant \sum_{i=1}^nz_i\geqslant\sum_{i=1}^ny_i">

### C++实现

首先按重量对货箱排序，然后按重量递增顺序，把货箱装上船，排序用时O(nlogn)，其中n是货箱数量，算法的其余部分用时O(n)，因此程序的复杂性为O(nlogn)。

## 0/1背包问题

### 问题描述

有n个物品和一个容量为c的背包，从n个物品中选出装包的物品。物品i的重量为w_i，价值为p_i。一个可行的背包装载是指，物品总价值最高的可行的背包装载。问题的公式描述是

<img src="https://latex.codecogs.com/png.latex?max\sum_{i=1}^np_ix_i">

约束条件是

<img src="https://latex.codecogs.com/png.latex?\sum_{i=1}^nw_ix_i\leqalant c ">且<img src="https://latex.codecogs.com/png.latex?x_i\in \{0,1\},1\leqslant i\leqslant n">

在这个问题中其实就是一般化的货箱装载问题，只是从每个货箱所获的的价值不同。

### 可能的贪心策略

- 从剩余的物品中选出可以放入背包的价值最大的物品。
- 从剩余的物品选出可装入背包的重量最小的物品。
- 从剩余物品中选出可装入包的<img src="https://latex.codecogs.com/png.latex?p_i/w_i">值最大的物品。

### 贪婪启发式算法

上述几个贪婪算法都不能保证得到最优解，但这是一个很好的启发式算法，而且在更多时候，它的解非常接近最优解。

我们可以修改贪婪启发式算法，使解的结果和最优解之差在最优解的x%（x<100)之内。首先，将最多k个物品放入背包。如果这k个物品重量大于c，则放弃它。否则，根据背包剩余的容量，考虑将剩余物品按<img src="https://latex.codecogs.com/png.latex?p_i/w_i">的递减顺序装入背包。考虑最多有k个物品的所有可能的子集而得到的最好的解就是启发式方法产生的解。

偏差百分比

k|0|1%|5%|10%|25%
0|239|390|528|583|600
1|360|527|598|600|\
2|483|581|600|\|\

由修改后的贪婪启发式方法得到的解称为K阶优化。而且这种方法获得的值在最优解的(100/(k+1))%以内，所以这种启发式方法称为有界性能启发式。有界性能启发式方法的数目为<img src="https://latex.codecogs.com/png.latex?O(n^k)">，每一个子集所需时间为O(n)，还有物品按价值比率排序所需时间为O(nlogn)。因此当k>0时，总时间为<img src="https://latex.codecogs.com/png.latex?O(n^{k+1})>"。

## 拓扑排序

### 问题描述

一个复杂的工程，经常可以分解成一组简单一些的任务，这些任务完成了，整个工程也就完成了。而且任务之间具有先后关系，这组任务和人物的先后顺序可用有向图表示————称为顶点活动（AOV）网络。

对于任务有向图得到任意一条比(i,j)，在这个序列中，任务i一定在任务j的前面，具有这样性质的序列称为拓扑序列。根据任务有向图建立拓扑序列的过程称为拓扑序列。

### 贪婪求解

每次选择任意一个入度为0的点加入序列，并将与该点有关的边删除。如果不满足贪婪规则则无法构建拓扑序列。

### 贪婪算法的正确性

需要证明：

1）当算法失败时，有向图没有拓扑序列

证明：

当算法失败时，所构造的序列长度小于顶点数，且没有顶点可以加入序列当中。因此必然有一个节点q1不在序列当中，则必然有指向q1的一条边(q1,q2)，始q1入度不为0，无法加入序列。同理，存在另一条边(q3,q2)指向
q2，存在另一条边(q4,q3)指向q3。

若q3=q1，则形成环路，若q3!=q1，若q4=q1，则依然形成环路，以此类推，因为有向图的顶点数是有限的，所以总能找到一个环路。

2）当算法没有失败，构造的序列为拓扑序列

### 复杂性分析

如果使用邻接矩阵描述，第一个for循环计算入度的时间开销为<img src="https://latex.codecogs.com/png.latex?O(v^2)">，如果使用邻接链表描述，则用时O(v+e)。这里v代表顶点数，e代表边数。第二个for循环遍历顶点并把入度为0的顶点压栈用时O(v)。在两个嵌套的while循环中，外层循环执行v次，每次将栈中顶点弹出，并对内层循环初始化。使用邻接矩阵时，内层while循环遍历所有顶点寻找入读为0顶点用时O(v)，若使用邻接链表需用时小于O(v)，因此内层while循环的开销为<img src="https://latex.codecogs.com/png.latex?O(v^2)">或O(v+e)。结果，若利用邻接矩阵复杂性为<img src="https://latex.codecogs.com/png.latex?O(n^2)">，若利用邻接链表则为O(v+e)。

## 二分覆盖

### 问题描述

二分图是一个无向图，它的n个顶点可以划分成两个集合：集合A和集合B，使任何一条边的两个顶点都在不同集合中。A的一个子集A'覆盖集合B（简单的说，A'是一个覆盖），当且仅当B的每个顶点至少与A'的一个顶点相连。覆盖A'的大小即为A‘的顶点数目。A'是最小覆盖，当且仅当A没有更小的子集覆盖B。

在二分图中找最小覆盖的问题称为二分覆盖问题。

### 贪婪启发式方法

集合覆盖问题为NP-复杂问题。由于集合覆盖和二分覆盖是同一类问题，二分覆盖也是NP-复杂问题。

贪婪准则：从A中选一个顶点，最大数量地覆盖了B中还未被覆盖的元素。

可以证明：

1）算法找不到覆盖，当且仅当初始的二分图没有覆盖。

2）二分图存在，但启发式方法找不到二分图的最小覆盖。

### 复杂度分析

更新各顶点的度需要O(e)，若使用邻接矩阵，则需要<img src="https://latex.codecogs.com/png.latex?\theta(v^2)">的时间来寻找图中的边，若用邻接链表，则需要<img src="https://latex.codecogs.com/png.latex?\theta(v+e)">的时间。所以实际更新时间为<img src="https://latex.codecogs.com/png.latex?O(v^2)">或O(v+e)。

在选择顶点时，所需时间为<img src="https://latex.codecogs.com/png.latex?\theta(A)">，因为A中每个顶点都有被选择的可能，所以所需步骤数为O(A)。所以总的复杂度为<img src="https://latex.codecogs.com/png.latex?O(A^2+v^2)=O(v^2)">或<img src="https://latex.codecogs.com/png.latex?O(A^2+v+e)">。

### 降低复杂度

使用有序数组、大根堆或最大选择树，可将每步开始阶段选取顶点v的复杂度降为<img src="https://latex.codecogs.com/png.latex?\theta(1)">。

## 单源最短路径

### 问题描述

给定一个加权有向图G，它的每条边(i,j)都有一个非负的成本（或长度）a[i][j]。一条路径的长度是该条路径所有边的成本之和。寻找一条从一个给定顶点出发到达其他任意一个顶点的最短路径。

### 贪婪法求解

贪婪准则：从一条最短路径还没有到达的顶点中，选择一个可以产生最短路径的目的顶点。

1. 选择起始节点，更新从该节点所有能到达的节点权值，并标记该点已遍历。
2. 选择未遍历的最小权值的节点，更新从该点出发的所有能到达的节点权值。
3. 重复第二步，直到所有节点已遍历

### 复杂性分析

复杂度为O(v^2)。任何一个最短路径算法对每一条边都至少检查一次，所以最小可能时间为O(e)。

## 最小生成树

### Kruskal算法

#### 算法思想

分步选择n-1条边，每步选择一条边，贪婪准则：从剩下的边中选一条成本最小且不会产生环路的边加入已选择的边集。

#### 正确性证明

需要证明：

1）只要存在生成树，Kruskal算法总能产生一棵生成树；

令G为一个加权无向图，因为一个无向图有一棵生成树，当且仅当这个无向图是连通的。在该算法中丢弃的边只有产生环路的边，而环路上删除一条边仍然是连通图。因此如果G是连通图，那么算法终止时，必然能产生一棵生成树。

2）产生的生成树具有最小成本。

### Prim算法

贪婪准则：从剩余的边中，选择一条成本最小的边，并且把它加入已选的边集中形成一棵树。

### Solin算法

该算法的每一步选择若干条边。

1. 所选择的边和图的n个顶点一起构成一个生成树的森林。
2. 为森林的每棵树选择一条边，这条边成本最小，且仅有一个顶点在该树中。将这条边加入正在创建的生成树中。
3. 重复2。若在某一步结束的时候仅剩下一棵树，或已经没有剩余的边可供选择时，算法终止。