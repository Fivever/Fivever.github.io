---
published: true
layout: post
title: 数据结构复习
tags:
  - Data Structure
description: 基础数据结构知识点总结
toc: true
share: true
comments: true
---

# 数据结构复习

## 第一章 绪论

### 数据(Data)
- 是信息的载体，是描述客观事物的数、字符、以及所有能输入到计算机中，被计算机程序识别和处理的符号的集合。
	- 数值性数据（整数、定点数、浮点数）
	- 非数值性数据（文字数据）

### 数据元素（Data Element）
- 数据的基本单位。在计算机程序中常作为一个整体进行考虑和处理。
- 有时一个数据元素可以由若干数据项(Data Item)组成。数据项是具有独立含义的最小标识单位。
- 数据元素又称为元素、结点、记录

### 数据对象 (Data Object)
- 具有相同性质的数据元素的集合。
	- 整数数据对象 N = { 0, 1, 2, … }
	- 字母字符数据对象 C={ ‘A’, ‘B’, ‘C’, … ‘F’ }

### 数据结构（Data Structure）
- 形式定义
某一数据对象的所有数据成员之间的关系。记为：
        
	Data_Structure = {D, S}
            
其中，D 是某一数据对象， S 是该对象中所有数据成员之间的关系的有限集合。

### 四个基本结构
- 集合
- 线性结构
- 树形结构
- 网状结构

### 数据的逻辑结构
- 从逻辑关系上描述数据，与数据的存储无关；
- 从具体问题抽象出来的数据模型；
- 与数据元素本身的形式、内容无关；
- 与数据元素的相对位置无关。

### 数据的逻辑结构分类
- 线性结构
	- 线性表
- 非线性结构
	- 树
	- 图（或网络）

### 数据的存储结构（物理结构）
- 数据结构在计算机中的表示。
- 数据的存储结构依赖于计算机语言。
	- 顺序存储表示
	- 链接存储表示
	- 索引存储表示
	- 散列存储表示

### 数据处理
- 将数据通过人力或机器，将收集到的数据加以系统的处理，归纳出有价值的信息。
  - 编辑（edit）：将存在某种媒体上的数据经过计算机复制到另一媒体时，对输入的数据逐一检查，其目的在于改变数据的存储形式和效率，以便后面的处理。
  - 排序（sort）：将数据根据某一键值，以某种顺序排序后输出，其目的在于方便其他方面的数据处理。
  - 归并（merge）：将两种以上相同性质的文件数据归并在一起。
  - 分配（distribute）：将一个文件的数据按照某一基准分配在两个以上的存储体，其目的在于方便各个分配的文件能独自处理。
  - 建档（generate）：根据某些条件规格，配合某些已存在的文件，再产生一个新的且有利用价值的文件。
  - 更新（update）：根据数据的变动来更新主档案，以保持主档案的正确与完整性。
  - 计算（compute）：将读取的文件数据，依据规定方法计算处理。
  - 链表（list）：是一种数据的集合，也就是一系列的数据存储于内存，以某种关系来连接这些相关联的数据。
  - 查找（search）：输入一个键值到数据表中进行对照，找出具有相同键值的数据。
  - 查询（inquiry）：根据数据项的键值或条件，到主档案中找出符合该条件或键值相同的数据，依照用户指定的方法输出。
  - 其它处理：分类（classifying）、摘要（summarizing）、变换(transmission)。

### 数据类型

	一个值的集合和定义在这个值集上的一组操作的总称。
        
- C语言中的基本数据类型

|int|char|float|double|void|
|---|----|-----|------|----|
|整型|字符型|浮点型|双精度型|无值|

### 抽象数据类型
- 是指一个数学模型以及定义在此数学模型上的一组操作
- 数据结构+定义在此数据结构上的一组操作 = 抽象数据类型
- 例如：矩阵 +（求转置、加、乘、求逆、求特征值）构成一个矩阵的抽象数据类型

### 抽象数据类型的描述
- 抽象数据类型可用（D，S，P）三元组表示，其中，D是数据对象，S是D上的关系集，P是对D的基本操作集。      

      ADT 抽象数据类型名
      {
          数据对象：〈数据对象的定义〉
          数据关系：〈数据关系的定义〉
          基本操作：〈基本操作的定义〉
      } ADT 抽象数据类型名

- 其中，数据对象、数据关系用伪码描述；

基本操作定义格式为
		
      基本操作名（参数表）
	  初始条件：〈初始条件描述〉
	  操作结果：〈操作结果描述〉
      
  - 基本操作有两种参数：赋值参数只为操作提供输入值；引用参数以&打头， 除可提供输入值外，还将返回操作结果。
  - “初始条件”描述了操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。
  - “操作结果”说明了操作正常完成之后，数据结构的变化状况和应返回的结果。若初始条件为空，则省略之。

### 抽象数据类型的表示和实现 
- 抽象数据类型可以通过固有数据类型(高级编程语言中已实现的数据类型)来实现
  - 抽象数据类型	  类 class
  - 数据对象       数据成员
  - 基本操作       成员函数(方法)
- 在C++中，类的成分(数据成员和成员函数)可以有三种访问级别
	- Private  私有成分（只允许类的成员函数进行访问）
	- protected 保护成分（只允许类的成员函数及其子孙类进行访问）
	- public 公有成分（允许类的成员函数、类的实例及其子孙类、子孙类的实例进行访问）

### 程序的产生
- 五个阶段：
1. 需求（输入、输出）
2. 设计（编写算法）
3. 分析（选择最佳算法）
4. 细化与编码（编写程序）
5. 验证（程序验证、测试、调试）

### 算法分析
- 算法定义：
		为了解决某类问题而规定的一个有限长的操作序列。
- 特性：
  - 有穷性  算法在执行有穷步后能结束
  - 确定性  每步定义都是确切、无歧义
  - 可行性  每一条运算应足够基本
  - 输入    有0个或多个输入
  - 输出    有一个或多个输出

### 性能分析与度量
- 算法的性能标准
  - 正确性：
    - 不含语法错误
    - 对几组数据运行正确
    - 对典型、苛刻的数据运行正确；
    - 对所有数据运行正确
  - 可读性
  - 效率：高效、低存储需要。（算法执行时间短，同时所占用的存储空间小）
  - 健壮性：当输入非法数据时，算法也能作出适当反应，而不会出现莫名其妙的输出结果。

### 算法的事前估计
- 空间复杂度度量
  - 存储空间的固定部分
  
   程序指令代码的空间，常数、简单变量、定长成分(如数组元素、结构成分、对象的数据成员等)变量所占空间
  - 可变部分
  
   尺寸与实例特性有关的成分变量所占空间、引用变量所占空间、递归栈所用空间、通过new和delete命令动态使用空间
- 时间复杂度度量
  - 运行时间 = 算法中每条语句执行时间之和。
  - 每条语句执行时间 = 该语句的执行次数（频度）* 语句执行一次所需时间。
  - 语句执行一次所需时间取决于机器的指令性能和速度和编译所产生的代码质量，很难确定。
  - 设每条语句执行一次所需时间为单位时间，则一个算法的运行时间就是该算法中所有语句的频度之和。
- 时间复杂度
	- 时间复杂度
    	即算法中语句重复执行次数的数量级就是时间复杂度。
	- 表示方法：
		T(n)=O(f(n))
      - f(n)表示基本操作重复执行的次数，是n的某个函数，随问题规模n的增大，算法执行时间的增长率和f(n)的增长率属于同一数量级；
      - O表示f(n)和T(n)只相差一个常数倍。
      - T（n)称做渐进时间复杂度，简称时间复杂度。

## 第二章 线性表
### 线性表
- 定义：
		
        n（0）个数据元素的有限序列，记作（a1,…, ai-1, ai, ai+1,…, an）
        其中,ai 是表中数据元素，n 是表长度。
- 特点: 
  - 同一线性表中元素具有相同特性。
  - 相邻数据元素之间存在序偶关系。
  - 除第一个元素外，其他每一个元素有一个且仅有一个直接前驱。
  - 除最后一个元素外，其他每一个元素有一个且仅有一个直接后继。	

### 顺序表
- 定义：

	  将线性表中的元素相继存放在一个连续的存储空间中。

- 存储结构：数组。
- 特点：线性表的顺序存储方式。
- 存取方式：顺序存取、随机存取
    
### 顺序表（SeqList）的类型定义
``` cpp
typedef struct list
{
    ElementType *data;
    int length;
}SeqList;
```

### 顺序表基本运算
- 初始化
  ``` cpp
  void InitList(SeqList &L)
  {//Initialize the sequence list
      L.data = (ElementType*)malloc(ListSize*sizeof(ElementType));
      if(L.data==NULL)
          printf("Initialize the sequence list failed\n");
      L.length = 0;
  }
  ```
- 按值查找
  ``` cpp
  int FindData(SeqList L, ElementType e)
  {//To find the position of a value
      for(int i=0; i<L.length; i++)
          if(L.data[i]==e)
              return i;
      printf("Not found\n");
      return -1;
  }
  ```

- 求表的长度
  ``` cpp
  int Length (SeqList L)
  {
      return L.length; 
  }
  ```

- 提取函数
  ``` cpp
  int GetData(SeqList L, int i)
  {//get the ith data in sequence list
      if(i<L.length)
          return L.data[i];
      return -1;
  }
  ```

- 按值查找：寻找x的后继
  ``` cpp
  int Next(SeqList L, ElementType x)
  {
      int i = FindData(L, x);
      if (i>=0 && i+1<L.length) return i+1;
      else return -1;
  }
  ```

- 寻找x的前驱
  ``` cpp
  int Previous(SeqList L, ElementType x)
  {
      int i = FindData(L, x);
      if (i>0 && i<L.length) return i-1;
      else return -1;
  }
  ```

- 顺序表的插入
  ``` cpp
  void Insert(SeqList &L, int i, ElementType x)
  {//Insert a data to sequence list
      if(L.length+1<=ListSize && i>=0 && i <=L.length)
      {
          for(int k=L.length-1; k>=i;k--)
              L.data[k+1]=L.data[k];
          L.data[i]=x;
          L.length++;
      }
  }
  ```

- 顺序表的删除
  ``` cpp
  void Delete(SeqList &L, ElementType x)
  {//Delete a data in sequence list
      int i=FindData(L,x);
      if(i!=-1)
      {
          for(int k=i; k<L.length-1;k++)
              L.data[k]=L.data[k+1];
          L.length--;
      }
  }
  ```

### 单链表
- 定义
		用一组地址任意的存储单元存放线性表中的数据元素。
        
- 单链表结构
  - 每个元素由结点(Node)构成,它包括两个域:数据域Data和指针域Link
  - 存储结构：链式存储结构
  - 特点：存储单元可以不连续。
  - 存取方式：顺序存取。

### 单链表（LinkList）的类型定义
``` cpp
typedef struct node
{//define the structure of link list
    ElementType data;
    struct node *next;
}ListNode;
```

### 单链表的基本运算
- 插入（三种情况）
  - 第一种情况：在第一个结点前插入
  - 第二种情况：在链表中间插入    
  - 第三种情况：在链表末尾插入
  
    ``` cpp
    void Insert(ListNode *L, int i, ElementType x)
    {//Insert a data to link list
        int k=1;
        while(k<i && L!=NULL)
            L=L->next, k++;
        if(k>=i)
        {
            ListNode *p=(ListNode*)malloc(sizeof(ListNode));
            ListNode *q=L->next;
            L->next=p;
            p->next=q;
            p->data=x;
        }
        else
            printf("Insert failed\n");
    }
    ```

- 删除
  ``` cpp
  void Delete(ListNode *L, ElementType x)
  {//Delete a data in link list
      while(L->next!=NULL)
          if(L->next->data==x)
              break;
      if(L->next!=NULL)
      {
          ListNode *p=L->next;
          L->next=p->next;
          free(p);
      }
      else
          printf("The data doexn't exist\n");
  }
  ```

- 建立单链表（前插法和后插法）
  ``` cpp
  ListNode* CreateList()
  {//Create a link list
      int cnt, x;
      ListNode *L=(ListNode*)malloc(sizeof(ListNode));
      printf("Please input the length of the list:");
      scanf("%d",&cnt);
      printf("Please input the elements of the list:");
      for(int i=0;i<cnt;i++)
      {
          scanf("%d",&x);
          Insert(L,i+1,x);
      }
      return L;
  }
  ```

- 单链表清空
  ``` cpp
  void Destroy(ListNode *L)
  {//Destroy the link list
      ListNode *p;
      while(L != NULL)
      {
          p = L;
          L = L->next;
          free(p);
      }
  }
  ```
- 计算单链表长度
  ``` cpp
  int Length(ListNode *L)
  {//get the length of link list
      int cnt=0;
      while(L->next!=NULL)
          cnt++, L=L->next;
      return cnt;
  }
  ```

- 按值查找
  ``` cpp
  int FindData(ListNode* L, ElementType e)
  {//To find the position of value e
      int i=1;
      while(L->next!=NULL)
          if(L->next->data==e)
              return i;
          else i++, L=L->next;
      printf("Not found\n");
      return -1;
  }
  ```

- 按序号查找（定位）
  ``` cpp
  int GetData(ListNode *L, int i)
  {//get the ith data in link list
      int k=1;
      while(k<=i && L!=NULL)
          L=L->next, k++;
      if(k>i)
          return L->data;
      else
      printf("The ith data doesn't exist\n");
      return -1;
  }
  ```

### 循环链表
- 特点:最后一个结点的 link 指针不为NULL，而是指向头结点。只要已知表中某一结点的地址，就可搜寻所有结点的地址。
- 存储结构:链式存储结构

### 循环链表类型定义
``` cpp
typedef struct node
{//define the structure of link list
    ElementType data;
    struct node *next;
}ListNode;
```

### 双向链表 (Doubly Linked List)
### 双向循环链表的定义
``` cpp
typedef struct node
{
    ElementType data;                          
    struct node *prior, *next;     
} DblNode;
```
### 双向循环链表的基本运算
  - 建立空的双向循环链表
    ``` cpp
    DblNode* CreateDblList (DblNode *first)
    {//Create the first node of Bidirectional circular linked list
        first = (DblNode*)malloc(sizeof(DblNode));
        if (first == NULL)
        {
            printf("ERROR!\n");
            exit (1);
        }
        first->prior = first->next = first;
        return first;
    }
    ```
  - 计算双向循环链表的长度
    ``` cpp
    int getLength(DblNode *first)
    {//Get the length of list
        DblNode *p = first->next;
        int count = 0;
        while (p != first) 
        {
            p = p->next;
            count++;
        }
        return count;
    }
    ```
  - 循环链表的定位
    ``` cpp
    DblNode* Locate(DblNode *first, int i)
    {//Locate the ith position in list
        DblNode *p = first->next;
        while(p != first && i)
        {
            p=p->next;
            i--;
        }
        return p;
    }
    ```
  - 双向循环链表的插入
    ``` cpp
    bool Insert (DblNode *first, int i, ElementType x)
    {//Insert the x to ith position in list
        DblNode *p = Locate(first, i-1);   
        if (p == first && i != 1) return false;
        DblNode * q = (DblNode*) malloc(sizeof(DblNode));
        q->data = x;
        q->next = p;
        q->prior = p->prior;
        p->prior->next = q;
        p->prior = q;
        return true;
    }
    ```
  - 双向循环链表的删除
    ``` cpp
    bool Delete(DblNode *first, int i)
    {//Delete the element in ith position
        DblNode *p = Locate(first,i-1);   
        if (p == first) return 0;
        p->next->prior = p->prior;
        p->prior->next = p->next; 
        free (p);
        return true;
    }
    ```

### 顺序表与链表的比较
- 基于空间的比较
   - 存储分配的方式
     - 顺序表的存储空间是静态分配的
     - 链表的存储空间是动态分配的
  - 存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量
    - 顺序表的存储密度 = 1
    - 链表的存储密度 < 1
- 基于时间的比较
  - 存取方式
    - 顺序表可以随机存取，也可以顺序存取
    - 链表是顺序存取的
  - 插入/删除时移动元素个数
    - 顺序表平均需要移动近一半元素
    - 链表不需要移动元素，只需要修改指针

## 第三章 栈
- 定义:是限定仅在表尾进行插入或删除操作的线性表。
- 允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)
- 特点：后进先出 (LIFO)

- 顺序栈：
		栈的顺序存储结构，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，
        指针top指向栈顶元素在顺序栈中的下一个位置，base为栈底指针，指向栈底的位置。
        
### 顺序栈的定义及存储表示
``` cpp
typedef struct
{
    ElementType *top, *base;
    int StackSize;
}SeqStack;
```
### 顺序栈的基本操作
- 初始化操作
  ``` cpp
  void InitStack(SeqStack &S)
  {//Initialize the sequence stack
      S.base=(ElementType*)malloc(STACKSIZE*sizeof(ElementType));
      S.top=S.base;
      S.StackSize = STACKSIZE;
  }
  ```
- 取栈顶操作
  ``` cpp
  ElementType GetTop(SeqStack S)
  {//return the top value of stack
      return *(S.top-1);
  }
  ```
- 进栈操作
  ``` cpp
  bool Push(SeqStack &S, ElementType x)
  {//push a value to the top of stack
      if (S.top-S.base>=S.StackSize)
      {
          S.base=(ElementType*)realloc(S.base,(S.StackSize+STACKINCREMENT)*sizeof(ElementType));  
          if(!S.base) exit(-1);
          S.top=S.base+S.StackSize;
          S.StackSize+=STACKINCREMENT;
      }
      *S.top++=x;
      return true;
  }
  ```
- 出栈操作
  ``` cpp
  bool Pop(SeqStack &S)
  {//delete the top value of stack
      if (S.top == S.base)
          return false;  
      --S.top;
      return true;
  }
  ```
### 链式栈:栈的链接表示
- 链式栈无栈满问题，空间可扩充
- 插入与删除仅在栈顶处执行
- 链式栈的栈顶在链头
- 适合于多栈操作
### 链式栈的定义
- 链式栈 (LinkedStack）中结点的定义
  ``` cpp
  typedef struct Node
  {   ElementType data;
      struct Node *next;
  }LinkNode;
  ```
- 链式栈 (LinkedStack)结构定义
  ``` cpp
  typedef struct
  {   LinkNode *top;
      int length;
  }LinkStack;
  ```
### 链式栈 (LinkedStack)的基本操作
- 初始化操作
  ``` cpp
  void InitStack(LinkStack &S)
  {//Initialize the sequence stack
      S.top = NULL;
      S.length = 0;
  }
  ```
- 取栈顶操作
  ``` cpp
  ElementType GetTop(LinkStack S)
  {//return the top value of stack
      if(S.top==NULL)
          return 0;
      return S.top->data;
  }
  ```
- 进栈操作
  ``` cpp
  void Push(LinkStack &S, ElementType e)
  {//push a value to the top of stack
      LinkNode *p = (LinkNode*)malloc(sizeof(LinkNode));
      if(!p) exit(1);
      p -> data = e;
      p -> next = S.top;
      S.top = p;
      ++S.length;
  }
  ```
- 出栈操作
  ``` cpp
  bool Pop (LinkStack &S)
  {//delete the top value of stack
      if (!S.top)
          return false;
      else
      {
          LinkNode *q = S.top;
          S.top = S.top->next;
          --S.length;
          delete q;
          return true;
      }
  }
  ```

### 队列
- 定义:
		只允许在表的一端进行插入，而在另一端删除元素的线性表。
		在队列中，允许插入的一端叫队尾（rear）
		允许删除的一端称为对头(front)。
- 特点：先进先出 (FIFO)

### 链队列
- 链队列中，有两个分别指示队头和队尾的指针。
- 链式队列在进队时无队满问题，但有队空问题。

### 链式队列的定义
- 链式队列中结点的定义
  ``` cpp
  typedef struct Node
  {
      ElementType data;
      struct Node *next;
  }QueueNode;
  ```

- 链式队列中结构的定义
  ``` cpp
  typedef struct
  {
      QueueNode *front;
      QueueNode *rear;
  }LinkQueue;
  ```
### 链式队列的基本操作
- 初始化链式队列
  ``` cpp
  void InitQueue(LinkQueue &Q)
  {//initialize the queue
      Q.front=Q.rear=(QueueNode*)malloc(sizeof(QueueNode));  
       if (!Q.front) exit(0);
             Q.front->next=NULL;
  }
  ```

- 清除链式队列
  ``` cpp
  void DestroyQueue(LinkQueue &Q)
  {//destroy the link queue
      while(Q.front)
      {
          Q.rear = Q.front->next;
          free(Q.front);
          Q.front = Q.rear;   
      }
  }
  ```

- 入队操作
  ``` cpp
  void EnQueue(LinkQueue &Q, ElementType x)
  {//push the element to the end of queue
      QueueNode *p=(QueueNode*)malloc(sizeof(QueueNode));
      p->next=NULL;
      Q.rear->next=p;
      p->data=x;
      Q.rear=p;
  }
  ```

- 出队操作
  ``` cpp
  void DeQueue(LinkQueue &Q)
  {//pop the first element in the queue
      QueueNode *p=Q.front->next;
      Q.front->next=p->next;
      free(p);
  }
  ```

- 取队列首
  ``` cpp
  ElementType GetFront(LinkQueue Q)
  {//return the first element in the queue
      if(Q.rear!=Q.front)
          return Q.front->next->data;
  }
  ```

### 循环队列 (Circular Queue)
- 顺序队列：队列的顺序存储表示。
- 用一组地址连续的存储单元依次存放从队列头到队列尾的元素，指针front和rear分别指示队头元素和队尾元素的位置。
- 插入新的队尾元素，尾指针增1，rear = rear + 1，
- 删除队头元素，头指针增1， front = front + 1，
- 因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。
- 队满时再进队将溢出
- 解决办法：将顺序队列臆造为一个环状的空间，形成循环(环形)队列

### 循环队列的表示及基本操作
- 循环队列的定义
  ``` cpp
  typedef struct
  {
      ElementType *base;
      int front;
      int rear;
  }SeqQueue;
  ```
- 初始化循环队列
  ``` cpp
  bool InitQueue(SeqQueue &Q)
  {//Initialize the queue
      Q.base=(ElementType*)malloc(MAXSIZE*sizeof (ElementType));
      if (!Q.base) exit(1);
      Q.front = Q.rear = 0; 
      return true;
  }
  ```
- 入队
  ``` cpp
  bool EnQueue(SeqQueue &Q, ElementType e)
  {//Put the element in queue
      if ((Q.rear+1)%MAXSIZE==Q.front)
          return 0;
      Q.base[Q.rear] = e;
      Q.rear= (Q.rear+1)%MAXSIZE;
      return true;
  }
  ```
- 出队
  ``` cpp
  bool DeQueue(SeqQueue  &Q)
  {//Put the element off queue
      if(Q.rear==Q.front) return false;   
      Q.front= (Q.front+1)%MAXSIZE;
      return true;
  }
  ```
### 递归
- 定义
		若一个对象部分地包含它自己, 或用它自己给自己定义, 则称这个对象是递归的；
        若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程。
        
- 三种递归情况
  - 定义是递归的
    - 求解阶乘函数的递归算法
      ``` cpp
      long Factorial ( long n )
      {
          if ( n == 0 ) return 1;
          else return n * Factorial (n-1);
      }
      ```
    
    - 计算斐波那契数列函数Fib(n)的定义
      ``` cpp
      long Fib (long n)
      {
          if ( n <= 1 ) return n;
          else return Fib (n-1) + Fib (n-2);
      }
      ```
    
  - 数据结构是递归的
    - 搜索链表最后一个结点并打印其数值
      ``` cpp
      void Search (ListNode *f)
      {
          if (f -> link == NULL)
              printf("%d \n", f->data);
          else Search (f->link);
      }
      ```
    - 在链表中寻找等于给定值的结点,并打印其数值
      ``` cpp
      void Search ( ListNode *f, Type& x )
      {
          if ( f != NULL )
              if ( f -> data == x )
                  printf("%d \n", f->data);
              else Search ( f -> link, x );
      }
      ```
  - 问题的解法是递归的
    - 汉诺塔(Tower of Hanoi)问题的解法
      ``` cpp
      Void hanoi(int n, char x, char y,char z)
      {//将塔座x上按直径从小到大且自上而下编号为1到n的n个圆盘按规则
      //搬到塔座z上，y可以用作辅助塔座
          if(n==1) move(x,1,z); //将编号为1的圆盘从x移到z
          else
          {
              hanoi(n-1,x,z,y);//将x上编号为1到n-1的圆盘移到y,z作辅助塔
              move(x,n,z); //将编号为n的圆盘从x移到z
              hanoi(n-1,y,x,z);//将y上编号为1到n-1的圆盘移到z,x作辅助塔
          }
      }
      ```
## 树和二叉树
### 树的定义    
树是由 n (n  0) 个结点的有限集合。如果 n = 0，称为空树；如果 n > 0，则
- 有且仅有一个特定的称之为根(Root)的结点，它只有直接后继，但没有直接前驱；
- 当n > 1，除根以外的其它结点划分为 m (m >0) 个互不相交的有限集 T1, T2, …, Tm，其中每个集合本身又是一棵树，并且称为根的子树(SubTree)。
### 树的基本术语
- 结点：一个数据元素及指向其子树的分支。
- 结点的度：结点拥有的子树个数。
- 叶结点：度为零的结点。
- 子女：结点子树的根。
- 兄弟：同一结点子女。
- 祖先：根到该结点路径上的所有结点。
- 子孙：某结点为根的子树上的任意结点。
- 结点层次：从根开始，根为第一层，根的子女为第二层，以此类推。
- 树的深度（高度）：树中结点的最大层次数。
- 有序树：树中结点的子树由左向右有序。
- 森林：m(m!=0)棵互不相交的树。
### 二叉树 (Binary Tree)
- 定义

		一棵二叉树是结点的一个有限集合，
        该集合或者为空，或者是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。
- 特点：每个结点至多只有两棵子树（二叉树中不存在度大于2的结点）
- 性质
  - 在二叉树的第 i 层上至多有 2^i－1 个结点。(i>=1) 
  - 深度为 k 的二叉树至多有 2^k-1 个结点(k>=1)。
  - 对任何一棵二叉树T, 如果其叶结点数为 n0, 度为2的结点数为 n2,则n0＝n2＋1.
  - 具有 n(n>=0) 个结点的完全二叉树的深度为log2(n)＋1
  - 如将一棵有n个结点的完全二叉树自顶向下，同一层自左向右连续给结点编号0, 1, 2, …, n-1，则有以下关系： 
    - 若i = 0, 则 i 无双亲
    - 若i > 0, 则 i 的双亲为(i-1)/2
    - 若2*i+1 < n, 则 i 的左子女为 2*i+1，若2*i+2 < n, 则 i 的右子女为2*i+2
    - 若结点编号i为偶数，且i!=0,则左兄弟结点i-1
    - 若结点编号i为奇数，且i!=n-1,则右兄弟结点为i+1
    - 结点i 所在层次为log2(i+1)
  - 含有n个结点的二叉链表中有n+1个空链域

### 特殊形态的二叉树
- 满二叉树 (Full Binary Tree) 

一棵深度为k且有2k -1个结点的二叉树称为满二叉树。
- 完全二叉树 (Complete Binary Tree)

若设二叉树的高度为h，则共有h层。除第 h 层外，其它各层 (0  h-1) 的结点数都达到最大个数，第 h 层从右向左连续缺若干结点，这就是完全二叉树。
### 二叉树的存储结构
- 顺序存储
- 链式存储
### 二叉链表的定义
``` cpp
typedef struct node
{
    ElementType data; 
    struct node *leftChild, *rightChild;
} BinTreeNode;
```
### 二叉链表的基本操作
- 中序遍历 (Inorder Traversal)
  ``` cpp
  void InOrder (BinTreeNode *T)
  {//中序遍历
      if (T != NULL)
      {
          InOrder (T->leftChild);
          printf("%d ",T->data);
          InOrder(T->rightChild);
      }
  }
  ```
- 前序遍历 (Preorder Traversal)
  ``` cpp
  void PreOrder (BinTreeNode *T)
  {//前序遍历
      if (T != NULL)
      {
          printf("%d ",T->data);
          PreOrder(T->leftChild);
          PreOrder(T->rightChild);
      }
  }
  ```
- 后序遍历 (Postorder Traversal)
  ``` cpp
  void PostOrder(BinTreeNode *T)
  {//后序遍历
      if (T != NULL)
      {
          PostOrder(T->leftChild);
          PostOrder(T->rightChild);
          printf("%d ",T->data);
      }
  }
  ```
- 按前序建立二叉树
  ``` cpp
  BinTreeNode* CreateBinTree(BinTreeNode *T)
  {//Create binary tree
      int x;
      scanf("%d",&x);
      if (x==0) T=NULL;
      else
      {
          T=(BinTreeNode*)malloc(sizeof(BinTreeNode));
          T->data = x;
          T->leftChild=CreateBinTree(T->leftChild);
          T->rightChild=CreateBinTree(T->rightChild);
      }
     return T;
  }
  ```
- 计算二叉树结点个数
  ``` cpp
  int Node_Count (BinTreeNode *T)
  {//count the number of nodes
      if (T == NULL) return 0;
      else
          return 1 + Node_Count(T->leftChild) + Node_Count(T->rightChild);
  }
  ```
- 求二叉树中叶子结点的个数
  ``` cpp
  int Leaf_Count(BinTreeNode *T)
   {//count the number of leaves
      if(!T) return 0;
      else if(!T->leftChild && !T->rightChild) return 1;
      else return Leaf_Count(T->leftChild)+Leaf_Count(T->rightChild);
  }
  ```
- 求二叉树高度
  ``` cpp
  int getHeight(BinTreeNode *T) 
  {//get the height of tree
      if ( T == NULL ) return 0;
      else
      {
          int m = getHeight(T->leftChild);
          int n = getHeight(T->rightChild); 
          return (m > n) ? m+1 : n+1;
      } 
  }
  ```
- 复制二叉树
  ``` cpp
  BinTreeNode* Copy( BinTreeNode * T ) 
  {//copy the same tree
      if ( T == NULL ) return NULL;
      BinTreeNode *Temp=(BinTreeNode *)malloc(sizeof(BinTreeNode)); 
      Temp->data=T->data;
      Temp->leftChild = Copy(T->leftChild); 
      Temp->rightChild = Copy(T->rightChild);
      return Temp;
  }
  ```
- 判断二叉树等价
  ``` cpp
  bool isEqual( BinTreeNode *a, BinTreeNode *b)
  {//compare twe binary trees
       if (a == NULL && b == NULL) return 1;
       if (a != NULL && b != NULL && a->data==b->data 
          && isEqual( a->leftChild, b->leftChild)
          && isEqual( a->rightChild, b->rightChild)) 
          return true;
      return false;
  }
  ```

## 第十章 内部排序
### 概述
- 排序(sorting)：将一个数据元素的任意序列，重新排列成一个按关键字有序的序列。 
- 数据表(datalist)：它是待排序数据对象的有限集合。
- 主关键字(key)：数据对象有多个属性域, 即多个数据成员组成, 其中有一个属性域可用来区分对象, 作为排序依据，称为关键字。也称为排序码。

### 排序方法的稳定性

如果在对象序列中有两个对象r[i]和r[j], 它们的排序码 k[i] == k[j], 且在排序之前, 对象r[i]排在r[j]前面。如果在排序之后, 对象r[i]仍在对象r[j]的前面, 则称这个排序方法是稳定的, 否则称这个排序方法是不稳定的。

### 内排序分类
- 依不同原则
  插入排序、交换排序、选择排序、归并排序、和基数排序等。
- 依所须工作量
  - 简单排序---时间复杂度O(n2)
  - 先进排序方法---时间复杂度O(nlogn)
  - 基数排序---时间复杂度O(d.n)

### 直接插入排序 (Insert Sort)
- 原理

		通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
        插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

- 算法
  ``` cpp
  void insertion_sort(int arr[],int len)
  {
      for(int i=1;i<len;i++)
      {
          int key=arr[i];
          int j=i-1;
          while((j>=0) && (key<arr[j]))
          {
              arr[j+1]=arr[j];
              j--;
          }
          arr[j+1]=key;
      }
  }
  ```

- 直接插入排序复杂度分析
  - 最好情况
   序列已经是升序排列了，在这种情况下，需要进行的比较操作需n-1次即可。
  - 最坏情况
   序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。
  - 稳定的算法

### 快速排序
- 实现

  使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。

  步骤为：

   1. 从数列中挑出一个元素，称为“基准”（pivot），
   2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。
   3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。

     递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

- 快速排序复杂度分析
  - 最坏时间复杂度：O(n^2)
  - 最优时间复杂度：O(nlog n)
  - 不稳定的算法

### 堆排序
- 算法
  ``` cpp
  void max_heapify(int arr[], int start, int end)
  {
      // 建立父節點指標和子節點指標
      int dad = start;
      int son = dad * 2 + 1;
      while (son <= end)
      { // 若子節點指標在範圍內才做比較
          if (son + 1 <= end && arr[son] < arr[son + 1]) // 先比較兩個子節點大小，選擇最大的
              son++;
          if (arr[dad] > arr[son]) // 如果父節點大於子節點代表調整完畢，直接跳出函數
              return;
          else
          { // 否則交換父子內容再繼續子節點和孫節點比較
              swap(arr[dad], arr[son]);
              dad = son;
              son = dad * 2 + 1;
          }
      }
  }

  void heap_sort(int arr[], int len)
  {
      // 初始化，i從最後一個父節點開始調整
      for (int i = len / 2 - 1; i >= 0; i--)
          max_heapify(arr, i, len - 1);
      // 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢
      for (int i = len - 1; i > 0; i--)
      {
          swap(arr[0], arr[i]);
          max_heapify(arr, 0, i - 1);
      }
  }
  ```
- 堆排序复杂度分析
  - 最坏时间复杂度：O(nlog n)
  - 最优时间复杂度：O(nlog n)
  - 不稳定的算法
