---
published: true
layout: post
title: 数据结构复习
tags:
  - Data Structure
description: 基础数据结构知识点总结
toc: true
share: true
comments: true
---

# 数据结构复习

## 第一章 绪论

### 数据(Data)
- 是信息的载体，是描述客观事物的数、字符、以及所有能输入到计算机中，被计算机程序识别和处理的符号的集合。
	- 数值性数据（整数、定点数、浮点数）
	- 非数值性数据（文字数据）

### 数据元素（Data Element）
- 数据的基本单位。在计算机程序中常作为一个整体进行考虑和处理。
- 有时一个数据元素可以由若干数据项(Data Item)组成。数据项是具有独立含义的最小标识单位。
- 数据元素又称为元素、结点、记录

### 数据对象 (Data Object)
- 具有相同性质的数据元素的集合。
	- 整数数据对象 N = { 0, 1, 2, … }
	- 字母字符数据对象 C={ ‘A’, ‘B’, ‘C’, … ‘F’ }

### 数据结构（Data Structure）
- 形式定义
		某一数据对象的所有数据成员之间的关系。记为：
			Data_Structure = {D, S}
		其中，D 是某一数据对象， S 是该对象中所有数据成员之间的关系的有限集合。

### 四个基本结构
- 集合
- 线性结构
- 树形结构
- 网状结构

### 数据的逻辑结构
- 从逻辑关系上描述数据，与数据的存储无关；
- 从具体问题抽象出来的数据模型；
- 与数据元素本身的形式、内容无关；
- 与数据元素的相对位置无关。

### 数据的逻辑结构分类
- 线性结构
	- 线性表
- 非线性结构
	- 树
	- 图（或网络）

### 数据的存储结构（物理结构）
- 数据结构在计算机中的表示。
- 数据的存储结构依赖于计算机语言。
	- 顺序存储表示
	- 链接存储表示
	- 索引存储表示
	- 散列存储表示

### 数据处理
- 将数据通过人力或机器，将收集到的数据加以系统的处理，归纳出有价值的信息。
  - 编辑（edit）：将存在某种媒体上的数据经过计算机复制到另一媒体时，对输入的数据逐一检查，其目的在于改变数据的存储形式和效率，以便后面的处理。
  - 排序（sort）：将数据根据某一键值，以某种顺序排序后输出，其目的在于方便其他方面的数据处理。
  - 归并（merge）：将两种以上相同性质的文件数据归并在一起。
  - 分配（distribute）：将一个文件的数据按照某一基准分配在两个以上的存储体，其目的在于方便各个分配的文件能独自处理。
  - 建档（generate）：根据某些条件规格，配合某些已存在的文件，再产生一个新的且有利用价值的文件。
  - 更新（update）：根据数据的变动来更新主档案，以保持主档案的正确与完整性。
  - 计算（compute）：将读取的文件数据，依据规定方法计算处理。
  - 链表（list）：是一种数据的集合，也就是一系列的数据存储于内存，以某种关系来连接这些相关联的数据。
  - 查找（search）：输入一个键值到数据表中进行对照，找出具有相同键值的数据。
  - 查询（inquiry）：根据数据项的键值或条件，到主档案中找出符合该条件或键值相同的数据，依照用户指定的方法输出。
  - 其它处理：分类（classifying）、摘要（summarizing）、变换(transmission)。

### 数据类型
		一个值的集合和定义在这个值集上的一组操作的总称。
        
- C语言中的基本数据类型

|int|char|float|double|void|
|---|----|-----|------|----|
|整型|字符型|浮点型|双精度型|无值|

### 抽象数据类型
- 是指一个数学模型以及定义在此数学模型上的一组操作
- 数据结构+定义在此数据结构上的一组操作 = 抽象数据类型
- 例如：矩阵 +（求转置、加、乘、求逆、求特征值）构成一个矩阵的抽象数据类型

### 抽象数据类型的描述
- 抽象数据类型可用（D，S，P）三元组表示，其中，D是数据对象，S是D上的关系集，P是对D的基本操作集。      

        ADT 抽象数据类型名 {
            数据对象：〈数据对象的定义〉
            数据关系：〈数据关系的定义〉
            基本操作：〈基本操作的定义〉
        } ADT 抽象数据类型名

- 其中,数据对象、数据关系用伪码描述；基本操作定义格式为
		
        基本操作名（参数表）
		初始条件：〈初始条件描述〉
		操作结果：〈操作结果描述〉
- 基本操作有两种参数：赋值参数只为操作提供输入值；引用参数以&打头， 除可提供输入值外，还将返回操作结果。
- “初始条件”描述了操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。
- “操作结果”说明了操作正常完成之后，数据结构的变化状况和应返回的结果。若初始条件为空，则省略之。

### 抽象数据类型的表示和实现 
- 抽象数据类型可以通过固有数据类型(高级编程语言中已实现的数据类型)来实现
  - 抽象数据类型	  类 class
  - 数据对象       数据成员
  - 基本操作       成员函数(方法)
- 在C++中，类的成分(数据成员和成员函数)可以有三种访问级别
	- Private  私有成分（只允许类的成员函数进行访问）
	- protected 保护成分（只允许类的成员函数及其子孙类进行访问）
	- public 公有成分（允许类的成员函数、类的实例及其子孙类、子孙类的实例进行访问）

### 程序的产生
- 五个阶段：
1. 需求（输入、输出）
2. 设计（编写算法）
3. 分析（选择最佳算法）
4. 细化与编码（编写程序）
5. 验证（程序验证、测试、调试）

### 算法分析
- 算法定义：
		为了解决某类问题而规定的一个有限长的操作序列。
- 特性：
  - 有穷性  算法在执行有穷步后能结束
  - 确定性  每步定义都是确切、无歧义
  - 可行性  每一条运算应足够基本
  - 输入    有0个或多个输入
  - 输出    有一个或多个输出

### 性能分析与度量
- 算法的性能标准
  - 正确性：
    - 不含语法错误
    - 对几组数据运行正确
    - 对典型、苛刻的数据运行正确；
    - 对所有数据运行正确
  - 可读性
  - 效率：高效、低存储需要。（算法执行时间短，同时所占用的存储空间小。
  - 健壮性：当输入非法数据时，算法也能作出适当反应，而不会出现莫名其妙的输出结果。

### 算法的事前估计
- 空间复杂度度量
  - 存储空间的固定部分
  
   程序指令代码的空间，常数、简单变量、定长成分(如数组元素、结构成分、对象的数据成员等)变量所占空间
  - 可变部分
  
   尺寸与实例特性有关的成分变量所占空间、引用变量所占空间、递归栈所用空间、通过new和delete命令动态使用空间
- 时间复杂度度量
  - 运行时间 = 算法中每条语句执行时间之和。
  - 每条语句执行时间 = 该语句的执行次数（频度）* 语句执行一次所需时间。
  - 语句执行一次所需时间取决于机器的指令性能和速度和编译所产生的代码质量，很难确定。
  - 设每条语句执行一次所需时间为单位时间，则一个算法的运行时间就是该算法中所有语句的频度之和。
- 时间复杂度
	- 时间复杂度
    	即算法中语句重复执行次数的数量级就是时间复杂度。
	- 表示方法：
		T(n)=O(f(n))
      - f(n)表示基本操作重复执行的次数，是n的某个函数，随问题规模n的增大，算法执行时间的增长率和f(n)的增长率属于同一数量级；
      - O表示f(n)和T(n)只相差一个常数倍。
      - T（n)称做渐进时间复杂度，简称时间复杂度。

## 第二章 线性表
### 线性表
  - 定义：
		
        n（0）个数据元素的有限序列，记作（a1, …ai-1, ai, ai+1,…, an）
        其中,ai 是表中数据元素，n 是表长度。
  - 特点: 
    - 同一线性表中元素具有相同特性。
    - 相邻数据元素之间存在序偶关系。
    - 除第一个元素外，其他每一个元素有一个且仅有一个直接前驱。
    - 除最后一个元素外，其他每一个元素有一个且仅有一个直接后继。	

### 顺序表
    - 定义：
            
            将线性表中的元素相继存放在一个连续的存储空间中。           
    - 存储结构：数组。
    - 特点：线性表的顺序存储方式。
    - 存取方式：顺序存取、随机存取
    
### 顺序表（SeqList）的类型定义
``` cpp
typedef struct list
{
    ElementType *data;
    int length;
}SeqList;
```

### 顺序表基本运算
- 初始化
  ``` cpp
  void InitList(SeqList &L)
  {//Initialize the sequence list
      L.data = (ElementType*)malloc(ListSize*sizeof(ElementType));
      if(L.data==NULL)
          printf("Initialize the sequence list failed\n");
      L.length = 0;
  }
  ```
- 按值查找
  ``` cpp
  int FindData(SeqList L, ElementType e)
  {//To find the position of a value
      for(int i=0; i<L.length; i++)
          if(L.data[i]==e)
              return i;
      printf("Not found\n");
      return -1;
  }
  ```

- 求表的长度
  ``` cpp
  int Length (SeqList &L)
  {
      return L.length; 
  }
  ```

- 提取函数
  ``` cpp
  int GetData(SeqList L, int i)
  {//get the ith data in sequence list
      if(i<L.length)
          return L.data[i];
      return -1;
  }
  ```

- 按值查找：寻找x的后继
  ``` cpp
  int Next (SeqList &L, ElementType x)
  {
      int i = FindData(x);
      if (i >0 && i < L.length) return i+1;
      else return -1;
  }
  ```

- 寻找x的前驱
  ``` cpp
  int Previous (SeqList &L, ElementType x)
  {
      int i = FindData(x);
      if ( i >0 && i < L.length ) return i-1;
      else return -1;
  }
  ```

- 顺序表的插入
  ``` cpp
  void Insert(SeqList &L, int i, ElementType x)
  {//Insert a data to sequence list
      if(L.length+1<=ListSize && i>=0 && i <=L.length)
      {
          for(int k=L.length-1; k>=i;k--)
              L.data[k+1]=L.data[k];
          L.data[i]=x;
          L.length++;
      }
  }
  ```

- 顺序表的删除
  ``` cpp
  void Delete(SeqList &L, ElementType x)
  {//Delete a data in sequence list
      int i=FindData(L,x);
      if(i!=-1)
      {
          for(int k=i; k<L.length-1;k++)
              L.data[k]=L.data[k+1];
              L.length--;
      }
  }
  ```

### 单链表
- 定义
		用一组地址任意的存储单元存放线性表中的数据元素。
        
- 单链表结构
  - 每个元素由结点(Node)构成,它包括两个域:数据域Data和指针域Link
  - 存储结构：链式存储结构
  - 特点：存储单元可以不连续。
  - 存取方式：顺序存取。

### 单链表（LinkList）的类型定义
``` cpp
typedef struct node
{//define the structure of link list
    ElementType data;
    struct node *next;
}ListNode;
```

### 单链表的基本运算
- 插入（三种情况）
  - 第一种情况：在第一个结点前插入
  - 第二种情况：在链表中间插入    
  - 第三种情况：在链表末尾插入
  
    ``` cpp
    void Insert(ListNode *L, int i, ElementType x)
    {//Insert a data to link list
        int k=1;
        while(k<i && L!=NULL)
            L=L->next, k++;
        if(k>=i)
        {
            ListNode *p=(ListNode*)malloc(sizeof(ListNode));
            ListNode *q=L->next;
            L->next=p;
            p->next=q;
            p->data=x;
        }
        else
            printf("Insert failed\n");
    }
    ```

- 删除
  ``` cpp
  void Delete(ListNode *L, ElementType x)
  {//Delete a data in link list
      while(L->next!=NULL)
          if(L->next->data==x)
              break;
      if(L->next!=NULL)
      {
          ListNode *p=L->next;
          L->next=p->next;
          free(p);
      }
      else
          printf("The data doexn't exist\n");
  }
  ```

- 建立单链表（前插法和后插法）
  ``` cpp
  ListNode* CreateList()
  {//Create a link list
      int cnt, x;
      ListNode *L=(ListNode*)malloc(sizeof(ListNode));
      printf("Please input the length of the list:");
      scanf("%d",&cnt);
      printf("Please input the elements of the list:");
      for(int i=0;i<cnt;i++)
      {
          scanf("%d",&x);
          Insert(L,i+1,x);
      }
      return L;
  }
  ```

- 单链表清空
- 计算单链表长度
  ``` cpp
  int Length(ListNode *L)
  {//get the length of link list
      int cnt=0;
      while(L->next!=NULL)
          cnt++, L=L->next;
      return cnt;
  }
  ```

- 按值查找
  ``` cpp
  int FindData(ListNode* L, ElementType e)
  {//To find the position of value e
      int i=1;
      while(L->next!=NULL)
          if(L->next->data==e)
              return i;
          else i++, L=L->next;
      printf("Not found\n");
      return -1;
  }
  ```

- 按序号查找（定位）
  ``` cpp
  int GetData(ListNode *L, int i)
  {//get the ith data in link list
      int k=1;
      while(k<=i && L!=NULL)
          L=L->next, k++;
      if(k>i)
          return L->data;
      else
      printf("The ith data doesn't exist\n");
      return -1;
  }
  ```

### 循环链表
- 特点:最后一个结点的 link 指针不为NULL，而是指向头结点。只要已知表中某一结点的地址，就可搜寻所有结点的地址。
- 存储结构:链式存储结构

### 循环链表类型定义
``` cpp
```

### 双向链表 (Doubly Linked List)
### 双向循环链表的定义
``` cpp
```
### 双向循环链表的基本运算
  - 建立空的双向循环链表
  ``` cpp
  ```
  - 计算双向循环链表的长度
  ``` cpp
  ```
  - 双向循环链表的插入 (非空表)
  ``` cpp
  ```
  - 双向循环链表的插入 (空表)
  ``` cpp
  ```
  - 双向循环链表的删除
  ``` cpp
  ```

### 顺序表与链表的比较
- 基于空间的比较
   - 存储分配的方式
     - 顺序表的存储空间是静态分配的
     - 链表的存储空间是动态分配的
  - 存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量
    - 顺序表的存储密度 = 1
    - 链表的存储密度 < 1
- 基于时间的比较
  - 存取方式
    - 顺序表可以随机存取，也可以顺序存取
    - 链表是顺序存取的
  - 插入/删除时移动元素个数
    - 顺序表平均需要移动近一半元素
    - 链表不需要移动元素，只需要修改指针

## 第三章 栈
- 定义:是限定仅在表尾进行插入或删除操作的线性表。
- 允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)
- 特点：后进先出 (LIFO)

- 顺序栈：
		栈的顺序存储结构，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，
        指针top指向栈顶元素在顺序栈中的下一个位置，base为栈底指针，指向栈底的位置。
### 顺序栈的定义及存储表示
``` cpp
typedef struct
{
	ElementType* data;
    int top;
}SeqStack;
```
### 顺序栈的基本操作
- 初始化操作
  ``` cpp
  void InitStack(SeqStack &S)
  {//Initialize the sequence stack
      S.data=(ElementType*)malloc(StackSize*sizeof(ElementType));
      S.top=-1;
  }
  ```
- 取栈顶操作
  ``` cpp
  ElementType GetTop(SeqStack S)
  {//return the top value of stack
      return S.data[S.top];
  }
  ```
- 进栈操作
  ``` cpp
  void Push(SeqStack &S, ElementType x)
  {//push a value to the top of stack
      if(S.top<StackSize)
      {
          S.top++;
          S.data[S.top]=x;
      }
  }
  ```
- 出栈操作
  ``` cpp
  void Pop(SeqStack &S)
  {//delete the top value of stack
      if(S.top>0)
          S.top--;
  }
  ```
### 链式栈:栈的链接表示
- 链式栈无栈满问题，空间可扩充
- 插入与删除仅在栈顶处执行
- 链式栈的栈顶在链头
- 适合于多栈操作
### 链式栈的定义
- 链式栈 (LinkedStack)中结点的定义
  ``` cpp
  ```
- 链式栈 (LinkedStack)结构定义
  ``` cpp
  ```
### 链式栈 (LinkedStack)的基本操作
- 初始化操作
  ``` cpp
  ```
- 取栈顶操作
  ``` cpp
  ```
- 进栈操作
  ``` cpp
  ```
- 出栈操作
  ``` cpp
  ```

### 队列
- 定义:
		只允许在表的一端进行插入，而在另一端删除元素的线性表。
		在队列中，允许插入的一端叫队尾（rear）
		允许删除的一端称为对头(front)。
- 特点：先进先出 (FIFO)

### 链队列
- 链队列中，有两个分别指示队头和队尾的指针。
- 链式队列在进队时无队满问题，但有队空问题。

### 链式队列的定义
- 链式队列中结点的定义
  ``` cpp
  typedef struct Node
  {
      ElementType data;
      struct Node *next;
  }QueueNode;
  ```

- 链式队列中结构的定义
  ``` cpp
  typedef struct
  {
      QueueNode *front;
      QueueNode *rear;
  }LinkQueue;
  ```
### 链式队列的基本操作
- 初始化链式队列
  ``` cpp
  void InitQueue(LinkQueue &Q)
  {//initialize the queue
      Q.front=Q.rear=(QueueNode*)malloc(sizeof(QueueNode));  
       if (!Q.front) exit(0);
             Q.front->next=NULL;
  }
  ```

- 清除链式队列
  ``` cpp
  void DestroyQueue(LinkQueue &Q)
  {//destroy the link queue
      while(Q.front)
      {
          Q.rear = Q.front->next;
          free(Q.front);
          Q.front = Q.rear;   
      }
  }
  ```

- 入队操作
  ``` cpp
  void EnQueue(LinkQueue &Q, ElementType x)
  {//push the element to the end of queue
      QueueNode *p=(QueueNode*)malloc(sizeof(QueueNode));
      p->next=NULL;
      Q.rear->next=p;
      p->data=x;
      Q.rear=p;
  }
  ```

- 出队操作
  ``` cpp
  void DeQueue(LinkQueue &Q)
  {//pop the first element in the queue
      QueueNode *p=Q.front->next;
      Q.front->next=p->next;
      free(p);
  }
  ```

- 取队列首
  ``` cpp
  ElementType GetFront(LinkQueue Q)
  {//return the first element in the queue
      if(Q.rear!=Q.front)
          return Q.front->next->data;
  }
  ```

### 循环队列 (Circular Queue)
- 顺序队列：队列的顺序存储表示。
- 用一组地址连续的存储单元依次存放从队列头到队列尾的元素，指针front和rear分别指示队头元素和队尾元素的位置。
- 插入新的队尾元素，尾指针增1，rear = rear + 1，
- 删除队头元素，头指针增1， front = front + 1，
- 因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。
- 队满时再进队将溢出
- 解决办法：将顺序队列臆造为一个环状的空间，形成循环(环形)队列

### 循环队列的表示及基本操作
### 递归
- 定义
		若一个对象部分地包含它自己, 或用它自己给自己定义, 则称这个对象是递归的；
        若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程。
        
- 三种递归情况
  - 定义是递归的
    - 求解阶乘函数的递归算法
      ``` cpp
      long Factorial ( long n )
      {
          if ( n == 0 ) return 1;
          else return n * Factorial (n-1);
      }
      ```
    
    - 计算斐波那契数列函数Fib(n)的定义
       ``` cpp
       long Fib (long n)
       {
           if ( n <= 1 ) return n;
           else return Fib (n-1) + Fib (n-2);
       }
       ```
    
  - 数据结构是递归的
    - 搜索链表最后一个结点并打印其数值
      ``` cpp
      void Search (ListNode *f)
      {
          if (f -> link == NULL)
              printf("%d \n", f->data);
          else Search (f->link);
      }
      ```
    - 在链表中寻找等于给定值的结点,并打印其数值
      ``` cpp
      void Search ( ListNode *f, Type& x )
      {
          if ( f != NULL )
              if ( f -> data == x )
                  printf("%d \n", f->data);
              else Search ( f -> link, x );
      }
      ```
  - 问题的解法是递归的
    - 汉诺塔(Tower of Hanoi)问题的解法
      ``` cpp
      Void hanoi(int n, char x, char y,char z)
      {//将塔座x上按直径从小到大且自上而下编号为1到n的n个圆盘按规则
      //搬到塔座z上，y可以用作辅助塔座
          if(n==1) move(x,1,z); //将编号为1的圆盘从x移到z
          else
          {
              hanoi(n-1,x,z,y);//将x上编号为1到n-1的圆盘移到y,z作辅助塔
              move(x,n,z); //将编号为n的圆盘从x移到z
              hanoi(n-1,y,x,z);//将y上编号为1到n-1的圆盘移到z,x作辅助塔
          }
      }
      ```
