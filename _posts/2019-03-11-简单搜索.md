---
published: true
layout: post
title: 简单搜索
tags:
  - 算法训练
description: 简单搜索算法的学习
toc: true
share: true
comments: true
---
# 简单搜索

## POJ 1321

题目链接：[http://poj.org/problem?id=1321]()

这道题简单来说就是，只能在'#'上放棋子，并且棋子不能在同行同列，求放置棋子的可能方法。

首先我们可以从第一行开始放置棋子，在第一行的一个位置上，如果在该列没有放置过棋子并且该位置为'#'则可以放置棋子，需要放置的棋子数就-1，然后开始第二行棋子的放置，以此类推。

通过上面的操作我们可以得出一种放置棋子的方法，那么要想求出所有的放置方法，这一类题目采用的就是利用堆栈来搜索。

首先我们对棋盘开始搜索，一旦搜索到了可以放置棋子的位置，则将这个状态先压入栈中，直接开始搜索从下一行开始的棋盘，直到需要放置的棋子全都放置完成，这时候开始回溯，我们发现在放置上一个棋子的时候，那一行并没有搜索完全我们就开始下一行的搜索了，回溯的意义就在于穷尽所有可能性，把之前没有搜索过的棋盘继续搜索完全。实现代码如下：

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int N=10;
char bd[N][N];//棋盘
bool ok[N];//判断该列是否放置过棋子
int cnt,n,k;//k是棋子个数，cnt是放置棋子的方法数

void dfs(int x)
{
    if(!k) cnt++;
    else
    {
        for(int i=x;i<n;i++)
            for(int j=0;j<n;j++)
                if(ok[j] && bd[i][j]=='#')
                {
                    k--, ok[j]=false;
                    dfs(i+1);
                    k++, ok[j]=true;
                }
    }
}
int main()
{
    while(scanf("%d%d",&n,&k) && n+1)
    {
        for(int i=0;i<n;i++)
            scanf("%s",bd[i]);
        memset(ok,true,sizeof(ok));
        cnt=0;
        dfs(0);
        printf("%d\n",cnt);
    }
}
```

## [POJ 2251](http://poj.org/problem?id=2251)

题目链接：[POJ 2251](http://poj.org/problem?id=2251)

这是一个三维的迷宫问题，并且要记录步数。
